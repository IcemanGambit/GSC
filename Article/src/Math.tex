\section{The Recommended Speed}\label{sec:Math}

We base the recommended speed, $\vel$ for arriving at the next traffic light while it is green, on the definition of velocity.
\begin{eqnarray}
\velrec = \frac{\dist}{\ti}\label{eq:Math:velocityDefinition}
\end{eqnarray}
where $\dist$ is the distance to the next traffic light and \ti is the time it has to cross that distance.

The driver should reach the junction just as it changes to green, because this will alow more vehichles to pass the junction afterwards.
However, the driver may not drive faster than the speed limit, $\velmax$.
If it is not possible to reach the next traffic light the first time it is green, then the driver should slow down and wait for the next time it is green.
By setting \ti in Equation~\ref{eq:Math:velocityDefinition} to when the green periode ends, \tslow, we find how slow the driver can drive and still cross the junction.
\begin{eqnarray}
\velslow = \frac{\dist}{\tslow}\label{eq:Math:velocitySlow}
\end{eqnarray}
Then, if $\velslow > \velmax$ then the driver should slow down and wait for the next time the connection has a green light.

\subsection{Green Spans}\label{sec:greenSpans}
Algorithm~\ref{alg.getSpans} details how to find the next green periodes or spans of a connection, \con at a given timestamp, \ti. 
The phase of \con is repeated, to give a sequence of spans that is terminated by an upper time limit, \tmax.
\tmax is in the following simuations set to 400 seconds, about $6.6$ minutes. %TODO: Check
The sequence consists of pairs of relative time values.
\[\langle(\ti_0, \ti_1), (\ti_2, \ti_3), \dots, (\ti_{n-1}, \ti_n)\rangle\]
Each value $\ti_i$ where $0\leq i\cdot 2\leq n$ is a timestamp after \ti when the signal for the connection turns green, and each value $\ti_j$ where $1\leq j\cdot 2\leq n-1$ is a timestamp after $\ti_{j-1}$ and before $\ti_{j+1}$ where the signal turns red.

To find these values, we first need to convert \phase into a sequence of green spans.
The for-loop in line~\ref{alg:getSpans:GreensFor} loops through the phase and adds start and end times to the sequence $greens$ where the signal is green.
A phase can have consecutive green signals, and while parsing a consecutive green periode, the starting time is stored in $\greenStart$.
Otherwise $\greenStart=-1$.
The start of a new green period has been found if the light setting is green, and $\greenStart=-1$, and $\ti'$ is stored (line~\ref{alg:getSpans:GreenBegin}).
The green periode ends when the light setting is not green and $s\neq -1$ (line~\ref{alg:getSpans:GreenEnd}) at which point the the start and end points are appended to $greens$ and \greenStart is reset.
The sequenc $greens$ will hence end up containing the periods when the connection has a green signal.
If $\cphase=\langle (green, 20), (yellow, 4), (red, 20), (yellow, 2)\rangle$ then $greens=\langle (0,20)\rangle$.

The loops in line~\ref{alg:getSpans:whilebegin} and~\ref{alg:getSpans:forbegin} continuously loops through $greens$ and add spans until the condition in line~\ref{alg:getSpans:breakCond} is met.
This happens when at least one span has been found and when the last element ends after \tmax seconds after \ti.
\ncirc in line~\ref{alg:getSpans:ncirc} is the number of times the the light has made a full circulation based on the number of seconds passed since the begining of the simulation and the circulation time of the phase, \Ccirc{\phase}.
The variable $i$ in line~\ref{alg:getSpans:i} is the number of extra circulations we look what to look into the future.
Hence $\tvar$ in line~\ref{alg:getSpans:tvar} is the number of seconds we need to add to the values in $greens$ from the start of the simuation.
If the time the green span ends plus the offset is larger than number of seconds the simulaion has run, then the span is added to the return seqeuence, \spans in line~\ref{alg:getSpans:add}.
By adding $\tstart + \tvar$ to the timestamp $\tsim$ we get the timestamp when the signal will be green. 
Likewise for \tend.
Using the same example as above, $\tmax=100$ and an abstract value for $\tsim=0$ we get that $getSpan(\con, 30)$ returns $\langle(46,66), (92,112)\rangle$.%TODO: Check

\begin{algorithm}
\caption{$getSpans(\con, \ti)$}\label{alg.getSpans}
\begin{algorithmic}[1]
\State $greens = \langle\ \rangle$
\State $\greenStart = -1$
\For{$(\light, \ti')\in \cphase$}\label{alg:getSpans:GreensFor}
\If{$\light = green$ and $\greenStart=-1$}\label{alg:getSpans:GreenBegin}
\State $\greenStart = \ti'$
\ElsIf{$\light\neq green$ and $\greenStart\geq0$}\label{alg:getSpans:GreenEnd}
\State $greens.add((\greenStart, \ti'))$
\State $\greenStart=-1$
\EndIf
\EndFor\label{alg:getSpans:GreensEnd}

\State \ncirc = $\left \lfloor \frac{\tsim-\ti}{\Ccirc{\cphase}} \right \rfloor$\Comment Number of circulations\label{alg:getSpans:ncirc}
\State $\spans = \langle\ \rangle$\label{alg:getSpans:initSpans}
\State $i = 0$\label{alg:getSpans:i}
\While{true}\label{alg:getSpans:whilebegin}
\For{$(\tstart, \tend)\in greens$}\label{alg:getSpans:forbegin}
\State $\tvar = (\ncirc+i)\cdot \Ccirc{\cphase}$\label{alg:getSpans:tvar}
\If {$\tend+\tvar> \tsim-\ti$}\Comment Reachable span
\State $\spans.add((\tstart + \tvar+\tsim, \tend + \tvar+ \tsim))$\label{alg:getSpans:add}
\EndIf
\EndFor
\State $(\tstart',\tend') = \spans.last()$ \Comment Last element
\If {$\spans.length > 0$ and $\tend' \geq \ti+\tmax$}\label{alg:getSpans:breakCond}
\State break\Comment Last span ends after max time
\EndIf
\State $i=i+1$
\EndWhile
\State\Return \spans
\end{algorithmic}
\end{algorithm}



\subsection{Recommended Speed}
Algorithm~\ref{alg.recommendedSpeed} shows the procedure for finding the recommended speed $\velrec$.
The input of the algorithm is the vehicle, \veh, the route that vehicle is traversing, \route and the map, $\map = (V, E, C)$.

First, we find the current speed limit, \velmax in line~\ref{alg:recSpeed:injunction} through~\ref{alg:recSpeed:injunctionEnd}. %TODO: whould it not be easier to let a connection have a speed limit, or is that just wrong?
If the vehicle currently is on a connection, i.e. in a junction, we use the speed limit of the previouse edge.
Otherwise, we use that of the current edge.

Next, we find the distance to the next connection, \cnext on the route, \route. 
This is looked up in line~\ref{alg:recSpeed:cnext}, and if there are no more connections, i.e. junctions, on the route then $\cnext=none$.
The distance function on line~\ref{alg:recSpeed:distance} calculates the eucledian distance from the vehicle to the connection.
In SUMO, one cannot get a distance to the connection, but only to the center point of the associated junction.
We therefore calculate the distance to the center of the junction and substract the average distance from the center to the outer egdes of the junctions geometric object. %TODO: Could we not just have added the lengths of the egdes? But then again this would not be a solution in the real world
If the connection is $none$, the distance is infinite.

In line~\ref{alg:recSpeed:getSpan}, we call the function $getSpans(\cnext, \ti)$ to get the sequence of timestamps where the phase is green.
We initialise the recommended speed and the slowest speed in line~\ref{alg:recSpeed:velrec} and \ref{alg:recSpeed:velslow}, respectively.
The for-loop in line~\ref{alg:recSpeed:loopSpans} to line~\ref{alg:recSpeed:loopSpansEnd} loops through the spans and finds the first span that the vehicle can reach.
First, we calculate the number of seconds before the light turns green and red in line~\ref{alg:recSpeed:tg} and~\ref{alg:recSpeed:tr}, respectively, and then calculate the slowest speed at which we can drive in order to reach the first green light in line~\ref{alg:recSpeed:hr}.
In line \ref{alg:recSpeed:continue} we check if this span is reachable and continue the for-loop to the next span if it is not. 
The span is not reachable if the slowest speed is higher than the maximal speed, meaning we whould have to driver faster than the speed limit, in order to reach it.

Knowing that this span is reachable, we calculate the recommended speed $\velrec$.
If the light is green right know, i.e. $\tgreen \leq 0$, then \velrec is the speed limit in line~\ref{alg:recSpeed:green}. 
Otherwise, we calculate $\velrec$ in line~\ref{alg:recSpeed:h} as in Equation~\ref{eq:Math:velocityDefinition}.

It is difficult to drive very slow, and we therefore set a lower limit of $\vellower=15km/h$ on the recommeneded speed in line~\ref{alg:recSpeed:lowerLimit}. 
By returning the minimum of \velrec and \velmax in line~\ref{alg:recSpeed:returnh} we ensure that we do not recommend a speed higher than the speed limit.
It might not be possible to find a reachable span, if the circulation time of the phase is larger than the look-ahead time, \tmax (see Section~\ref{sec:greenSpans}).
If so, we just return the maximum speed in line~\ref{alg:recSpeed:returnmax}.

Assume a speed limit of $\velmax = 16 m/s$ and that the vehicle is $500 m$ from the next connection, \con, and let  the timestamps be abstacted to seconds.
\begin{itemize}
\item If $getSpan(\con, 10)$ returns $\langle(0,20), (20,40), (60,80)\rangle$, Algorithm~\ref{alg.recommendedSpeed} will simply return \velmax as $0-10 \leq 0$.
\item If $getSpan(\con, 10)$ returns $\langle(20,50), (80,110)\rangle$, then \velslow is $12.5 m/s$.
The first span is therefore reachable. 
The recommeneded speed becomes $50m/s$ which is reduced to $16 m/s$ in order to stay below the speed limit.
\item If $getSpan(\con, 10)$ returns $\langle(15,30), (70,85)\rangle$, then \velslow is $25 m/s$ and the first span is not reachable.
Looking at the next span, \velslow becomes $6.6m/s$ which is less than the speed limit, and the final recommended speed is $8.3 m/s$.
\end{itemize}

\begin{algorithm}
\caption{recommendSpeed(\veh, \route, $(V, E, C)$)}\label{alg.recommendedSpeed}
\begin{algorithmic}[1]
\If {$\vehpos \in C$} \Comment \veh in a junction\label{alg:recSpeed:injunction}
\State\velmax= \espeed where \eend=\vehposstart
\Else\ \velmax = \vehposspeed
\EndIf\label{alg:recSpeed:injunctionEnd}

\State $\cnext= $ next \con in \route\Comment $\cnext=none$ if no junction ahead \label{alg:recSpeed:cnext}
\If {$\cnext\neq none$}\ $\dist=distance(\veh,\cnext)$ \label{alg:recSpeed:distance}
\Else\ $\dist = \infty$
\EndIf

\If{$d>\distmax$} \Return \velmax\Comment \cnext too far ahead
\EndIf
\State $\ti=$ current\_time()
\State $spans = getSpans(\cnext, \ti)$ \Comment Green spans of \cnext \label{alg:recSpeed:getSpan}

\State $\velrec = 0$ \Comment Recommended speed \label{alg:recSpeed:velrec}
\State $\velslow = 0$ \Comment Slowest speed for reaching a green light \label{alg:recSpeed:velslow}

\ForAll {$(\tstart, \tend)$ in $spans$}\label{alg:recSpeed:loopSpans}
\State $\tgreen = \tstart - \ti$ \Comment Seconds until \cnextphase is green \label{alg:recSpeed:tg}
\State $\tslow = \tend - \ti$ \Comment Seconds until \cnextphase is red\label{alg:recSpeed:tr}
\State $\velslow = \frac{\dist}{\tslow}$\label{alg:recSpeed:hr}

\State\Comment Span is not reachable
\If{$\velslow > \velmax$} continue\label{alg:recSpeed:continue}
\EndIf

\If{$\tgreen \leq 0$} $\velrec=\velmax$\Comment Light is green\label{alg:recSpeed:green}
\Else\ $\velrec = \frac{\dist}{\tgreen}$\Comment Light is not green\label{alg:recSpeed:h}
\EndIf
\State $\velrec = \max(\velrec, \vellower)$\Comment Set lower limit\label{alg:recSpeed:lowerLimit}
\State\Return $\min(\velrec, \velmax)$\Comment Set upper limit\label{alg:recSpeed:returnh}
\EndFor\label{alg:recSpeed:loopSpansEnd}

\State\Return $\velmax$\Comment No reachable green span\label{alg:recSpeed:returnmax}
\end{algorithmic}
\end{algorithm}

\subsection{Complexity and Communication Analysis}
Understanding the complexity and communication costs of the algorithm is important in order to know whether for example a smartphone implementation is feasable.

Algorithm~\ref{} has two parts: converting the phase, \phase to green spans and expanding these spans.
Remember $|\phase|$ is the number of elements in the phase, then converting the phase has a complexity of $O(|\phase|)$.
Expanding the phase will be dependent on both $|\phase|$ and the look-ahead time, $\tmax$, as the returned sequence is terminated when the last element ends after $\tmax$ seconds.
Hence the complexity of Algorithm~\ref{} is  $O(|\phase|+ |\phase|\cdot \tmax)$ which can be reduced to $O(|\phase|\cdot \tmax)$.

The complexity of Algorithm~\ref{} is three fold: checking if the vehicle is on a connection, finding the next connection on the route, getting the green spans and finding the speed.
Checking if the vehicles is on a connection will be $O(|C|)$ where $|C|$ denotes the number of connections in the network.
However, by setting a type on egdes and connections, this can be reduced to a simple lookup and hence $O(1)$.
Using this type, finding the next connection will then have a complexity of $O(\route)$.
This can however be precomputed such that the complexity also becomes $O(1)$.
The route is be the sequence of egdes and connections to be visited.
By keeping a reduced route with only the connections and the speed limit of the previouse egde, and popping this sequnce as connections are visited, then the complexity will be $O(1)$.
The complexity of getting the green spans is, as stated, $O(|\phase|\cdot \tmax)$.
Finding the speed is also $O(|\phase|\cdot \tmax)$ as it loops through the spans, and the content of the loop only has constant complexity.
In total, the complexity of Algorithm~\ref{} is $O(|\phase|\cdot\tmax)$.

\tmax is how far into the future we what the spans to go.
We predict that it often will not be neccessary to look more than $2\cdot |\phase|$ in to the future.
Phases are very rarely more than 120 seconds, so \tmax will be a small number and always constant.
The complexity of the algorithm will therefore be $O(|\phase|)$.
Additionally, $|\phase|$ will in most case be short and cannot be more than than the circulation time.
We can therefore conclude that the complexity of recommending a speed is minimal, and at most $O(\Ccirc{\phase})$.

The communication cost is also minimal.
We propose a anonymised, pull strategy where the smartphone asks a server for the spans of a traffic light given its identifier.
The pull request will therfore only contain a integer identifing the next traffic light on the route.
The respons will as explain above be propotional to the length of the phase, and hence $O(\Ccirc{\phase})$.
Each entry will be a pair of integers.
The request will in addition to the spans also contain the GPS location of the traffic light, being the latitude and longitude coordinates and hence two integers.
The communication cost is thereby also minimal and at most, $3\cdot s + O(\Ccirc{\phase})\cdot 2\cdot s + 2\cdot s$, where $s$ is the size of an integer.








